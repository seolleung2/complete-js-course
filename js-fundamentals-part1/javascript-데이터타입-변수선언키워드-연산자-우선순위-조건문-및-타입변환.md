# 자바스크립트 기초: 데이터 타입, 변수 선언, 연산자 우선순위, 조건문 및 타입 변환

## 데이터 타입

모든 값 (values)은 object 또는 primitive 자료형입니다.

이 강의에서는 원시 자료형에 대해 알아보겠습니다.

7가지 원시 자료형

- **number**: 숫자 값을 나타내며, 정수와 부동 소수점 숫자를 포함합니다.

  - 예: `42` // 정수
  - 예: `3.14` // 부동 소수점 숫자

- **string**: 문자들의 집합으로, 텍스트 데이터를 표현합니다.

  - 예: `"안녕하세요"` // 문자열
  - 예: `'JavaScript'` // 문자열

- **boolean**: 참(true) 또는 거짓(false) 값을 나타냅니다.

  - 예: `true` // 참
  - 예: `false` // 거짓

- **undefined**: 값이 할당되지 않은 변수를 나타내며, '빈 값'으로 간주됩니다.

  - 예: `let x; // x는 undefined`

- **null**: 의도적으로 '빈 값'을 나타내기 위해 사용됩니다.

  - 예: `let y = null; // y는 null`

- **symbol**: 고유하고 변경할 수 없는 값으로, 주로 객체의 프로퍼티 키로 사용됩니다.

  - 예: `const sym = Symbol('description'); // 심볼 생성`

- **bigInt**: 매우 큰 정수를 나타내기 위해 사용되며, 일반 number 타입이 표현할 수 있는 범위를 초과하는 값을 다룰 수 있습니다.
  - 예: `const bigIntValue = 1234567890123456789012345678901234567890n; // 큰 정수`

## 동적 타이핑

- **정의**: 자바스크립트는 동적 타이핑 언어로, 변수의 타입이 실행 중에 결정됩니다.

- **특징**:
  - 변수에 다양한 데이터 유형을 할당할 수 있습니다.
  - 같은 변수에 다른 타입의 값을 재할당할 수 있습니다.
- **장점**: 유연한 코드 작성이 가능하여 개발 속도가 빨라집니다.

- **단점**: 타입 오류를 사전에 방지하기 어려워, 런타임에서 버그가 발생할 수 있습니다.

- **비유**: 동적 타이핑은 마치 상자에 책을 넣었다가 다시 꺼내고 다른 물건을 넣는 것과 같습니다.

## undefined와 null의 차이

- **undefined**:

  - 변수가 선언되었지만 값이 할당되지 않은 상태를 나타냅니다.
  - 자바스크립트에서 자동으로 할당되는 값으로, 메모리에 존재하지만 값이 없기 때문에 크기가 작습니다.
  - 예: `let x; // x는 undefined`

- **null**:
  - 개발자가 의도적으로 '빈 값'을 할당한 상태를 나타냅니다.
  - 객체를 가리키는 포인터로, 메모리에 주소값을 할당받아 존재하지만 값은 없습니다.
  - 예: `let y = null; // y는 null`

### 메모리 측면에서의 차이

- `undefined`는 메모리에서 크기가 작고, 값이 없음을 나타내는 상태입니다.
- `null`은 빈 객체를 가리키는 포인터로, 메모리에서 크기가 더 큽니다.

### `typeof null`

- `typeof null`이 `object`인 이유는 자바스크립트의 역사적 유산으로, null이 객체로 잘못 분류되었기 때문입니다.
- 이는 자바스크립트의 타입 시스템에서 발생한 버그로 여겨집니다.

### 요약

- `undefined`는 변수의 초기화가 이루어지지 않은 상태이며, `null`은 개발자가 의도적으로 빈 값을 할당한 상태로 이해할 수 있습니다.

---

## let, const, and var

### 기본 개념

- **let**:

  - 변수를 선언할 때 사용하며, 블록 스코프를 따릅니다.
  - 같은 블록 내에서 동일한 이름으로 변수를 재선언할 수 없습니다.
  - 예:
    ```javascript
    let x = 10;
    if (true) {
      let x = 20; // 다른 블록에서의 x
      console.log(x); // 20
    }
    console.log(x); // 10
    ```

- **const**:

  - 상수를 선언할 때 사용하며, 블록 스코프를 따릅니다.
  - 선언과 동시에 초기화해야 하며, 재할당이 불가능합니다.
  - 객체나 배열의 경우, 내부 요소는 변경할 수 있습니다.
  - 예:
    ```javascript
    const y = 30;
    // y = 40; // 오류 발생
    const arr = [1, 2, 3];
    arr.push(4); // 가능
    console.log(arr); // [1, 2, 3, 4]
    ```

- **var**:
  - 변수를 선언할 때 사용하며, 함수 스코프를 따릅니다.
  - 블록 내에서 선언하더라도 함수 전체에서 접근 가능합니다.
  - 같은 이름으로 변수를 재선언할 수 있습니다.
  - 예:
    ```javascript
    var z = 50;
    if (true) {
      var z = 60; // 같은 함수 내에서의 z
      console.log(z); // 60
    }
    console.log(z); // 60
    ```

### 특징 및 차이점

| 특징          | let                        | const                      | var                        |
| ------------- | -------------------------- | -------------------------- | -------------------------- |
| 스코프        | 블록 스코프                | 블록 스코프                | 함수 스코프                |
| 재선언 가능성 | 불가능                     | 불가능                     | 가능                       |
| 초기화        | 선택적                     | 필수                       | 선택적                     |
| 호이스팅      | 가능 (초기화 전 접근 불가) | 가능 (초기화 전 접근 불가) | 가능 (초기화 전 접근 가능) |

### 스코프

- **블록 스코프**: `let`과 `const`는 블록 내에서만 유효하며, 블록이 끝나면 변수도 소멸됩니다. 이는 코드의 가독성을 높이고, 변수의 충돌을 방지하는 데 도움이 됩니다.

- **함수 스코프**: `var`는 함수 내에서만 유효하며, 함수가 종료되면 변수도 소멸됩니다. 블록 내에서 선언하더라도 함수 전체에서 접근할 수 있어, 예기치 않은 동작을 초래할 수 있습니다.

### 결론

- `const`를 기본으로 사용하고, 값이 변경될 가능성이 있는 경우에만 `let`을 사용하라고 권장합니다. `var`는 사용을 피하는 것이 좋습니다.

- 스코프의 이해는 변수를 효과적으로 관리하고, 코드의 예측 가능성을 높이는 데 중요합니다.

## Operator Precedence

연산자 우선순위(Operator Precedence)는 여러 연산자가 포함된 표현식에서 어떤 연산자가 먼저 실행되는지를 결정하는 규칙입니다.

우선순위가 높은 연산자는 먼저 평가되며, 이는 코드의 실행 결과에 큰 영향을 미칩니다.

### 기본 개념

- **우선순위**: 연산자의 우선순위는 숫자로 표현되며, 숫자가 낮을수록 우선순위가 높습니다. 예를 들어, `**` (지수 연산자)는 `*` (곱셈)보다 높은 우선순위를 가집니다.

- **결합성(Associativity)**: 동일한 우선순위를 가진 연산자들 간의 평가 순서를 정의합니다. 대부분의 연산자는 왼쪽에서 오른쪽으로 평가되지만, 일부 연산자는 오른쪽에서 왼쪽으로 평가됩니다.

### 예시

1. **우선순위에 따른 평가**:

   ```javascript
   console.log(3 + 10 * 2); // 23
   // 10 * 2가 먼저 실행되고, 그 결과에 3이 더해집니다.
   ```

2. **결합성에 따른 평가**:

   ```javascript
   const a = 4 ** (3 ** 2); // 262144
   // 오른쪽에서 왼쪽으로 평가되어 4 ** (3 ** 2)로 해석됩니다.
   ```

3. **괄호 사용**:
   ```javascript
   console.log((3 + 10) * 2); // 26
   // 괄호로 인해 3 + 10이 먼저 실행됩니다.
   ```

### 결론

연산자 우선순위와 결합성을 이해하는 것은 자바스크립트 코드의 실행 결과를 예측하는 데 매우 중요합니다. 이를 통해 복잡한 표현식을 작성할 때 의도한 대로 동작하도록 할 수 있습니다.

자세한 내용은 [MDN 웹 문서](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence)에서 확인할 수 있습니다.

## if - else

자바스크립트의 `if - else` 문은 조건에 따라 코드 블록을 실행하는 데 사용됩니다. 하지만 복잡한 조건문이 많아질 경우 가독성이 떨어질 수 있습니다.

아래는 `if - else` 문을 사용할 때 유용한 코드 작성 방식과 피해야 할 예시를 정리한 것입니다.

### 가독성을 높이는 코드 작성 방식

1. **명확한 조건 사용**:

   - 조건을 명확하게 작성하여 코드의 의도를 분명히 합니다.

   ```javascript
   if (user.isLoggedIn) {
     // 사용자 로그인 처리
   } else {
     // 로그인 페이지로 리다이렉트
   }
   ```

2. **중첩된 if 문 피하기**:

   - 중첩된 `if` 문은 가독성을 떨어뜨리므로, 가능한 한 피하는 것이 좋습니다. 대신 `else if`를 사용하거나, 조건을 함수로 분리합니다.

   ```javascript
   // 피해야 할 예시
   if (condition1) {
     if (condition2) {
       // 처리
     }
   }

   // 개선된 예시
   if (condition1 && condition2) {
     // 처리
   }
   ```

3. **switch 문 사용 고려**:

   - 여러 조건을 비교해야 할 경우 `switch` 문을 사용하는 것이 더 가독성이 좋을 수 있습니다.

   ```javascript
   switch (fruit) {
     case "apple":
       console.log("사과입니다.");
       break;
     case "banana":
       console.log("바나나입니다.");
       break;
     default:
       console.log("알 수 없는 과일입니다.");
   }
   ```

4. **삼항 연산자 사용**:
   - 간단한 조건문은 삼항 연산자를 사용하여 한 줄로 표현할 수 있습니다.
   ```javascript
   const message = isLoggedIn ? "환영합니다!" : "로그인 해주세요.";
   ```

### 피해야 할 if 문 예시

1. **복잡한 조건문**:

   - 여러 조건이 결합된 복잡한 `if` 문은 가독성을 떨어뜨립니다.

   ```javascript
   if (age > 18 && isStudent === false && hasPermission === true) {
     // 처리
   }
   ```

2. **중복된 코드**:

   - 같은 코드 블록이 여러 `if` 문에 중복될 경우, 함수로 분리하여 재사용성을 높입니다.

   ```javascript
   // 피해야 할 예시
   if (condition1) {
     // 중복 코드
   } else if (condition2) {
     // 중복 코드
   }

   // 개선된 예시
   function process() {
     // 중복 코드
   }

   if (condition1) {
     process();
   } else if (condition2) {
     process();
   }
   ```

### 결론

`if - else` 문을 사용할 때는 가독성을 고려하여 명확하고 간결한 코드를 작성하는 것이 중요합니다.

중첩된 조건문이나 복잡한 구조는 피하고, 필요에 따라 `switch` 문이나 삼항 연산자를 활용하여 코드를 깔끔하게 유지합시다.

## Type Conversion과 Type Coercion의 차이

자바스크립트에서 데이터 타입을 다룰 때 `type conversion`과 `type coercion`이라는 두 가지 개념이 있습니다. 이 두 용어는 비슷하게 들리지만, 서로 다른 의미를 가집니다.

### Type Conversion (타입 변환)

- **정의**: 명시적으로 데이터 타입을 변환하는 과정입니다. 프로그래머가 의도적으로 변환을 수행합니다.
- **예시**:

  - `String()` 함수를 사용하여 숫자를 문자열로 변환:

    ```javascript
    const num = 123;
    const str = String(num); // '123'
    console.log(typeof str); // 'string'
    ```

  - `Number()` 함수를 사용하여 문자열을 숫자로 변환:
    ```javascript
    const strNum = "456";
    const numConverted = Number(strNum); // 456
    console.log(typeof numConverted); // 'number'
    ```

### Type Coercion (타입 강제 변환)

- **정의**: 자바스크립트 엔진이 자동으로 데이터 타입을 변환하는 과정입니다. 프로그래머가 의도하지 않더라도 발생할 수 있습니다.
- **예시**:

  - 문자열과 숫자를 더할 때, 숫자가 문자열로 변환됩니다:

    ```javascript
    const result = 5 + "5"; // '55'
    console.log(result); // '55'
    ```

  - 비교 연산에서 타입이 자동으로 변환됩니다:
    ```javascript
    console.log(5 == "5"); // true
    // '5'가 숫자 5로 변환되어 비교됩니다.
    ```

### 요약

- **Type Conversion**: 프로그래머가 명시적으로 타입을 변환하는 것입니다.

- **Type Coercion**: 자바스크립트가 자동으로 타입을 변환하는 것입니다.

이 두 개념을 이해하는 것은 자바스크립트에서 데이터 타입을 효과적으로 다루는 데 중요합니다.

## Type Coercion과 버그

`Type Coercion`은 자바스크립트에서 자동으로 데이터 타입을 변환하는 과정으로, 때때로 예기치 않은 결과를 초래할 수 있습니다. 이러한 자동 변환은 코드의 가독성을 떨어뜨리고, 버그를 양산할 수 있는 원인이 됩니다. 따라서 `Type Coercion`을 이해하는 것이 중요합니다.

### Type Coercion으로 인한 버그 예시

1. **비교 연산에서의 문제**:

   - `==` 연산자는 타입을 강제로 변환하여 비교합니다. 이로 인해 의도하지 않은 결과가 발생할 수 있습니다.

   ```javascript
   console.log(0 == "0"); // true
   console.log(false == ""); // true
   console.log(null == undefined); // true
   ```

   이러한 결과는 코드의 의도를 명확히 이해하지 못하게 만들 수 있습니다.

2. **문자열과 숫자의 결합**:

   - 숫자와 문자열을 더할 때, 숫자가 문자열로 변환되어 예기치 않은 결과를 초래할 수 있습니다.

   ```javascript
   const a = 5;
   const b = "10";
   const result = a + b; // '510'
   console.log(result); // '510'
   ```

   이 경우, 숫자 5가 문자열로 변환되어 문자열 결합이 이루어집니다.

### 결론

`Type Coercion`은 자바스크립트의 유연성을 제공하지만, 동시에 버그를 양산할 수 있는 잠재적인 원인이 됩니다.

따라서, `===` (엄격한 동등 비교 연산자)를 사용하여 타입 변환을 피하고, 명시적인 타입 변환을 통해 코드를 작성하는 것이 좋습니다.

이를 통해 코드의 가독성을 높이고, 예기치 않은 동작을 방지할 수 있습니다.
